# %%
# Copyright (C) 2024 Analog Devices, Inc.
#
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without modification,
# are permitted provided that the following conditions are met:
#     - Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     - Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in
#       the documentation and/or other materials provided with the
#       distribution.
#     - Neither the name of Analog Devices, Inc. nor the names of its
#       contributors may be used to endorse or promote products derived
#       from this software without specific prior written permission.
#     - The use of this software may or may not infringe the patent rights
#       of one or more patent holders.  This license does not release you
#       from the requirement that you obtain separate licenses from these
#       patent holders to use this software.
#     - Use of the software either in source or binary form, must be run
#       on or directly connected to an Analog Devices Inc. component.
#
# THIS SOFTWARE IS PROVIDED BY ANALOG DEVICES "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A
# PARTICULAR PURPOSE ARE DISCLAIMED.
#
# IN NO EVENT SHALL ANALOG DEVICES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, INTELLECTUAL PROPERTY
# RIGHTS, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
# THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

'''FMCW Range Processing Data from the Phaser (CN0566)
   Jon Kraft, Oct 2 2024'''

# Imports
import time
import matplotlib # type: ignore
import matplotlib.pyplot as plt # type: ignore
import numpy as np
import argparse
import pandas as pd # type: ignore
plt.close('all')

# Parse the input file argument
parser = argparse.ArgumentParser(description='Process FMCW Range Data')
parser.add_argument('input_file', type=str, help='Path to the input .npy file')
args = parser.parse_args()

f = args.input_file
config = np.load(f[:-4]+"_config.npy")          # these files are generated by the "Range_Doppler_Plot.py" program
all_data = np.load(f)


MTI_filter = '2pulse'  # choices are none, 2pulse, or 3pulse
cfar_toggle = True     # Enable/disable CFAR filtering
cfar_method = 'average'  # CFAR method: 'average', 'greatest', 'smallest'
cfar_guard_cells_range = 3    # Number of guard cells in range dimension
cfar_guard_cells_doppler = 3  # Number of guard cells in Doppler dimension
cfar_ref_cells_range = 5      # Number of reference cells in range dimension
cfar_ref_cells_doppler = 5    # Number of reference cells in Doppler dimension
cfar_bias = 1          # CFAR bias/threshold in dB
cfar_min_value = None  # Will be set to min_scale later
custom_filter = False
if custom_filter:
    min_scale = 5
    max_scale = 10
step_thru_plots = False
time_divider = 1

""" Calculate and print summary of ramp parameters
"""
sample_rate = config[0]
signal_freq = config[1]
output_freq = config[2]
num_chirps = int(config[3])
chirp_BW = config[4]
ramp_time_s = config[5]
frame_length_ms = config[6]
max_doppler_vel = config[7] if len(config) > 7 else 2
if not custom_filter:
    max_scale = config[8] if len(config) > 8 else 10 
    min_scale = config[9] if len(config) > 9 else 0 
    if min_scale > max_scale:
        min_scale = 0
min_doppler_plot_vel = config[10] if len(config) > 10 else 2 
string_length = config[11] if len(config) > 11 else 2 
sample_goal = config[12] if len(config) > 12 else 2 
dist_from_centroid = config[13] if len(config) > 13 else 2 
time_data = pd.read_csv(f"{f[:-4]}_time.csv")
num_samples = len(all_data[0][0])

data_start_time = time_data.iloc[0, 0]  # Get first timestamp

PRI = frame_length_ms / 1e3
PRF = 1 / PRI

# Split into frames
N_frame = int(PRI * float(sample_rate))

# Obtain range-FFT x-axis
c = 3e8
wavelength = c / output_freq
slope = chirp_BW / ramp_time_s
freq = np.linspace(-sample_rate/2, sample_rate/2, N_frame)
dist = (freq - signal_freq - 25e3) * c / (2 * slope)
velocity_bins = np.linspace(-max_doppler_vel, max_doppler_vel, num_chirps)

# Resolutions
R_res = c / (2 * chirp_BW)
print(f"Range resolution: {R_res} m")
v_res = wavelength / (2 * num_chirps * PRI)
print(f"Velocity resolution: {v_res:.2f} m/s")

# Doppler spectrum limits
max_doppler_freq = PRF / 2
# max_doppler_vel = max_doppler_freq * wavelength / 2

print("sample_rate = ", sample_rate/1e6, "MHz, ramp_time = ", int(ramp_time_s*(1e6)), "us, num_chirps = ", num_chirps, ", PRI = ", frame_length_ms, " ms")
max_theoretical_vel = wavelength * PRF / 4
print(f"Theoretical max velocity: Â±{max_theoretical_vel:.2f} m/s")


# %%
# Function to process data
def pulse_canceller(radar_data):
    global num_chirps, num_samples
    rx_chirps = []
    rx_chirps = radar_data
    # create 2 pulse canceller MTI array
    Chirp2P = np.empty([num_chirps, num_samples])*1j
    for chirp in range(num_chirps-1):
        chirpI = rx_chirps[chirp,:]
        chirpI1 = rx_chirps[chirp+1,:]
        chirp_correlation = np.correlate(chirpI, chirpI1, 'valid')
        angle_diff = np.angle(chirp_correlation, deg=False)  # returns radians
        Chirp2P[chirp,:] = (chirpI1 - chirpI * np.exp(-1j*angle_diff[0]))
    # create 3 pulse canceller MTI array
    Chirp3P = np.empty([num_chirps, num_samples])*1j
    for chirp in range(num_chirps-2):
        chirpI = Chirp2P[chirp,:]
        chirpI1 = Chirp2P[chirp+1,:]
        Chirp3P[chirp,:] = chirpI1 - chirpI
    return Chirp2P, Chirp3P

def cfar_2d(range_doppler_data, num_guard_cells_range=4, num_guard_cells_doppler=2, 
           num_ref_cells_range=8, num_ref_cells_doppler=4, bias=3, cfar_method='average', 
           min_value=-200):
    range_size, doppler_size = range_doppler_data.shape
    filtered_data = np.full_like(range_doppler_data, min_value)
    threshold = np.zeros_like(range_doppler_data)
    
    # Define window sizes for processing
    guard_window_range = 2 * num_guard_cells_range + 1
    guard_window_doppler = 2 * num_guard_cells_doppler + 1
    ref_window_range = guard_window_range + 2 * num_ref_cells_range
    ref_window_doppler = guard_window_doppler + 2 * num_ref_cells_doppler
    
    # Calculate the number of reference cells
    num_ref_cells_total = ref_window_range * ref_window_doppler - guard_window_range * guard_window_doppler
    
    # For each cell under test (CUT)
    for i in range(range_size):
        for j in range(doppler_size):
            # Define window boundaries
            range_min = max(0, i - num_guard_cells_range - num_ref_cells_range)
            range_max = min(range_size, i + num_guard_cells_range + num_ref_cells_range + 1)
            doppler_min = max(0, j - num_guard_cells_doppler - num_ref_cells_doppler)
            doppler_max = min(doppler_size, j + num_guard_cells_doppler + num_ref_cells_doppler + 1)
            
            # Create mask for guard cells
            guard_range_min = max(0, i - num_guard_cells_range)
            guard_range_max = min(range_size, i + num_guard_cells_range + 1)
            guard_doppler_min = max(0, j - num_guard_cells_doppler)
            guard_doppler_max = min(doppler_size, j + num_guard_cells_doppler + 1)
            
            # Extract window and create guards mask
            window = range_doppler_data[range_min:range_max, doppler_min:doppler_max]
            mask = np.ones_like(window, dtype=bool)
            
            # Mask out guard cells and CUT
            local_guard_range_min = max(0, guard_range_min - range_min)
            local_guard_range_max = local_guard_range_min + (guard_range_max - guard_range_min)
            local_guard_doppler_min = max(0, guard_doppler_min - doppler_min)
            local_guard_doppler_max = local_guard_doppler_min + (guard_doppler_max - guard_doppler_min)
            
            mask[local_guard_range_min:local_guard_range_max, 
                 local_guard_doppler_min:local_guard_doppler_max] = False
            
            # Extract reference cells using mask
            ref_cells = window[mask]
            
            # Skip if no reference cells (edge case)
            if len(ref_cells) == 0:
                continue
                
            # Calculate threshold based on method
            if cfar_method == 'average':
                noise_level = np.mean(ref_cells)
            elif cfar_method == 'greatest':
                noise_level = np.max(ref_cells)
            elif cfar_method == 'smallest':
                noise_level = np.min(ref_cells)
            else:
                noise_level = np.mean(ref_cells)  # Default to average
            
            # Apply bias to get threshold
            cell_threshold = noise_level + bias
            threshold[i, j] = cell_threshold
            
            # Check if CUT is above threshold
            if range_doppler_data[i, j] > cell_threshold:
                filtered_data[i, j] = range_doppler_data[i, j]
    
    return filtered_data, threshold

def freq_process(data):
    rx_chirps_fft = np.fft.fftshift(abs(np.fft.fft2(data)))
    range_doppler_data = np.log10(rx_chirps_fft).T
    
    # Calculate total number of velocity bins
    num_vel_bins = range_doppler_data.shape[1]
    
    # Map each bin to its true velocity
    vel_bin_values = np.linspace(-max_theoretical_vel, max_theoretical_vel, num_vel_bins)
    
    # Find which bins are within our display range
    valid_bins = np.abs(vel_bin_values) <= max_doppler_vel
    
    # Zero out all bins outside our display range
    for i in range(len(valid_bins)):
        if not valid_bins[i]:
            range_doppler_data[:, i] = min_scale
    
    # Apply other processing
    num_good = len(range_doppler_data[:,0])   
    center_delete = 0  # delete ground clutter velocity bins around 0 m/s
    if center_delete != 0:
        for g in range(center_delete):
            end_bin = int(num_chirps/2+center_delete/2)
            range_doppler_data[:,(end_bin-center_delete+g)] = np.zeros(num_good)
    range_delete = 0   # delete the zero range bins (these are Tx to Rx leakage)
    if range_delete != 0:
        for r in range(range_delete):
            start_bin = int(len(range_doppler_data)/2)
            range_doppler_data[start_bin+r, :] = np.zeros(num_chirps)
    range_doppler_data = np.clip(range_doppler_data, min_scale, max_scale)  # clip the data to control the max spectrogram scale
    return range_doppler_data

# %%
# Plot range doppler data, loop through at the end of the data set
cmn = 'viridis'
i = 0
time_idx = 0
raw_data = freq_process(all_data[i])
# print(raw_data.shape)
# print(raw_data)
i=int((i+1) % len(all_data))

# Create the figure
range_doppler_fig, ax = plt.subplots(1, figsize=(7,7))

# Calculate the correct extent for imshow
# print(dist.max())
extent = [-max_theoretical_vel, max_theoretical_vel, dist.min(), dist.max()]
range_doppler = ax.imshow(raw_data, aspect='auto', 
                          extent=extent, 
                          origin='lower', 
                          cmap=matplotlib.colormaps.get_cmap(cmn))

# Set display limits (can be different from full theoretical range)
ax.set_xlim([-max_doppler_vel, max_doppler_vel])  # Display only part of the velocity range
ax.set_ylim([-1, dist.max()])
ax.set_yticks(np.arange(-1, int(dist.max()), 1))
ax.set_ylabel('Range [m]')
main_title = 'Range Doppler Spectrum'
time_subtitle = ax.text(0.5, 0.98, '', transform=ax.transAxes, 
                        ha='center', va='top', fontsize=10)
ax.set_title(main_title, pad=25)  # Add padding for subtitle
ax.set_xlabel('Velocity [m/s]')

print("CTRL + c to stop the loop")
if step_thru_plots == True:
    print("Press Enter key to adance to next frame")
    print("Press 0 then Enter to go back one frame")
try:
    playback_start_time = time.time()
    prev_time_idx = time_idx
    sample_rate_hz = 0.0  # Initial value
    
    # Set cfar_min_value now that min_scale is defined
    if cfar_min_value is None:
        cfar_min_value = min_scale
    
    while True:
        current_time = time_data.iloc[time_idx, 0]
        elapsed_time = current_time - data_start_time
        
        # Calculate the actual sample rate from the time data
        if time_idx > 0 and prev_time_idx != time_idx:
            prev_time = time_data.iloc[prev_time_idx, 0]
            time_delta = current_time - prev_time
            if time_delta > 0:
                sample_rate_hz = 1.0 / time_delta
            prev_time_idx = time_idx
        elif time_idx == 0 and prev_time_idx != 0:  # Loop around case
            prev_time = time_data.iloc[len(time_data)-1, 0]
            time_delta = (current_time + time_data.iloc[len(time_data)-1, 0]) - prev_time
            if time_delta > 0:
                sample_rate_hz = 1.0 / time_delta
            prev_time_idx = time_idx
        
        # Calculate time to wait for real-time playback
        current_playback_time = time.time() - playback_start_time
        target_time = elapsed_time * time_divider
        
        if MTI_filter != 'none':
            Chirp2P, Chirp3P = pulse_canceller(all_data[i])
            if MTI_filter == '3pulse':
                freq_process_data = freq_process(Chirp3P)
            else:
                freq_process_data = freq_process(Chirp2P)
        else:
            freq_process_data = freq_process(all_data[i])
        
        # Apply 2D CFAR filtering if enabled
        if cfar_toggle:
            cfar_filtered_data, _ = cfar_2d(
                freq_process_data,
                num_guard_cells_range=cfar_guard_cells_range,
                num_guard_cells_doppler=cfar_guard_cells_doppler,
                num_ref_cells_range=cfar_ref_cells_range,
                num_ref_cells_doppler=cfar_ref_cells_doppler,
                bias=cfar_bias,
                cfar_method=cfar_method,
                min_value=cfar_min_value
            )
            range_doppler.set_array(cfar_filtered_data)
        else:
            range_doppler.set_array(freq_process_data)
        
        
        # Update subtitle with time and recorded sample rate
        time_subtitle.set_text(f'Time: {elapsed_time:.2f} s | Sample Rate: {sample_rate_hz:.1f} Hz')
        
        plt.draw()
        plt.show(block=False)
        if current_playback_time < target_time:
            plt.pause(target_time - current_playback_time)
        else:
            plt.pause(0.001)  # Small pause to allow GUI to update
        if step_thru_plots == True:
            val = input()
            if val == '0':
                i=int((i-1) % len(all_data))
                time_idx = (time_idx-1) % len(time_data)
            else:
                i=int((i+1) % len(all_data))
                time_idx = (time_idx+1) % len(time_data)
        else:
            time_idx = (time_idx + 1) % len(time_data)
            i=int((i+1) % len(all_data))
            if time_idx == 0:
                playback_start_time = time.time() - (time_data.iloc[0, 0] - data_start_time) * time_divider
except KeyboardInterrupt:  # press ctrl-c to stop the loop
    pass